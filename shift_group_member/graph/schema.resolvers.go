package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"
	"shift_group_members/graph/generated"
	"shift_group_members/graph/model"
	"shift_group_members/util"
	"sync"
	"time"

	sentry "github.com/getsentry/sentry-go"
	"github.com/google/uuid"
	"gorm.io/gorm/clause"
)

// ShiftGroupMemberAdd is the resolver for the shiftGroupMemberAdd field.
func (r *mutationResolver) ShiftGroupMemberAdd(ctx context.Context, input model.ShiftGroupMemberInput, authUserID *string) (*model.ShiftGroupMemberAddResponse, error) {
	errorMessage := "Something went wrong while adding the shift group." // default error message

	// if authUserID == nil || *authUserID == string("") {
	// 	errorMessage = AUTH_USER_ID_REQUIRED
	// 	return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	// }

	var err error
	// permission := false

	// validate permission
	// permission, err = util.CheckPermission("shift_group_member", "WRITE_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	errorMessage = err.Error()
	// 	return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "WRITE", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		errorMessage = err.Error()
	// 		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	// 	}
	// }

	// if !permission {
	// 	errorMessage = "Permission denied: shift_group_member.WRITE, shift_group_member.WRITE_ALL"
	// 	return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	// }

	// validate the input
	if input.ChannelID == "" {
		errorMessage = "Channel id is required"
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	if input.ShiftGroupID == "" {
		errorMessage = "Shift group id is required"
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	if input.UserID == "" {
		errorMessage = "User id is required"
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	// check if the user is already a member of the shift group
	var shiftGroupMember model.ShiftGroupMember
	err = r.DB.Where("shift_group_id = ? AND channel_id = ? AND user_id = ?", input.ShiftGroupID, input.ChannelID, input.UserID).First(&shiftGroupMember).Error

	if shiftGroupMember.ID != "" {
		errorMessage = "User is already a member of the shift group"
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	}

	// create a shift group member
	defaultPosition := -1
	shiftGroupMember = model.ShiftGroupMember{
		ID:           uuid.New().String(),
		ChannelID:    input.ChannelID,
		ShiftGroupID: input.ShiftGroupID,
		UserID:       input.UserID,
		Position:     &defaultPosition,
		CreatedAt:    time.Now().UTC(),
	}

	// save the shift group member
	err = r.DB.Create(&shiftGroupMember).Error
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	}

	// get the user from the user service and return it
	user, err := util.GetUser(input.UserID)

	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		return util.ShiftGroupMemberAddRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	}

	return &model.ShiftGroupMemberAddResponse{
		Errors: nil,
		User:   user,
	}, nil
}

// ShiftGroupMembersReorder is the resolver for the shiftGroupMembersReorder field.
func (r *mutationResolver) ShiftGroupMembersReorder(ctx context.Context, channelID *string, shiftGroupID string, userIds []string, authUserID *string) (*model.ResponseStatus, error) {
	var message, status string
	// if authUserID == nil || *authUserID == string("") {
	// 	message = AUTH_USER_ID_REQUIRED
	// 	status = "error"
	// 	return &model.ResponseStatus{
	// 		Message: &message,
	// 		Status:  &status,
	// 	}, nil
	// }
	// var err error
	// permission := false

	// validate permission
	// permission, err = util.CheckPermission("shift_group_member", "WRITE_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	message = err.Error()
	// 	status = "error"
	// 	return &model.ResponseStatus{
	// 		Message: &message,
	// 		Status:  &status,
	// 	}, nil

	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "MANAGE", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		message = err.Error()
	// 		status = "error"
	// 		return &model.ResponseStatus{
	// 			Message: &message,
	// 			Status:  &status,
	// 		}, nil
	// 	}
	// }

	// if !permission {
	// 	message = "Permission denied: shift_group_member.MANAGE, shift_group_member.WRITE_ALL"
	// 	status = "error"

	// 	return &model.ResponseStatus{
	// 		Message: &message,
	// 		Status:  &status,
	// 	}, nil
	// }

	if len(userIds) <= 1 {
		message = "userIds must have at least 2 items"
		status = "error"
		return &model.ResponseStatus{
			Message: &message,
			Status:  &status,
		}, nil
	}

	var positions []int
	for i := 0; i < len(userIds); i++ {
		positions = append(positions, i+1)
	}

	var shiftGroupMembers []*model.ShiftGroupMember
	for i := 0; i < len(userIds); i++ {
		shiftGroupMember := model.ShiftGroupMember{
			ChannelID:    *channelID,
			ShiftGroupID: shiftGroupID,
			UserID:       userIds[i],
			Position:     &positions[i],
		}

		err := r.DB.Model(&shiftGroupMembers).Where("shift_group_id = ? AND channel_id = ? AND user_id = ?", shiftGroupID, channelID, userIds[i]).Updates(&shiftGroupMember).Error

		if err != nil {

			sentry.CaptureException(err)
			defer sentry.Flush(2 * time.Second)

			message = err.Error()
			status = "error"

			return &model.ResponseStatus{
				Message: &message,
				Status:  &status,
			}, nil
		}
	}

	message = "Shift group member order positions updated"
	status = "success"
	return &model.ResponseStatus{
		Message: &message,
		Status:  &status,
	}, nil
}

// ShiftGroupMemberRemove is the resolver for the shiftGroupMemberRemove field.
func (r *mutationResolver) ShiftGroupMemberRemove(ctx context.Context, channelID string, shiftGroupID string, userID string, authUserID *string) (*model.ShiftGroupMemberRemoveResponse, error) {
	errorMessage := "Something went wrong while removing the shift group." // default error message

	// if authUserID == nil || *authUserID == string("") {
	// 	errorMessage = AUTH_USER_ID_REQUIRED
	// 	return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	// }

	var err error
	// permission := false

	// validate permission
	// permission, err = util.CheckPermission("shift_group_member", "WRITE_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	errorMessage = err.Error()
	// 	return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "MANAGE", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		errorMessage = err.Error()
	// 		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	// 	}
	// }

	// if !permission {
	// 	errorMessage = "Permission denied: shift_group_member.MANAGE, shift_group_member.WRITE_ALL"
	// 	return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	// }

	// validate the input
	if channelID == "" {
		errorMessage = "channelId is required"
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	if shiftGroupID == "" {
		errorMessage = "shiftGroupId is required"
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	if userID == "" {
		errorMessage = "userId is required"
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	var assignedShifts []*model.AssignedShift

	assignedShifts, err = util.GetAssignedShiftsByChannelIDShiftGroupIDUserID(&channelID, &shiftGroupID, &userID)
	if err != nil {

		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeNotFound)
	}

	if len(assignedShifts) != 0 {
		//check if member has pending shifts
		isPendingShift := false
		var endDate time.Time
		for _, assignedShift := range assignedShifts {
			if &assignedShift.EndTime != nil {
				endDate = assignedShift.EndTime
				if endDate.After(time.Now()) {
					isPendingShift = true
					break
				}
			}
		}

		if isPendingShift {
			errorMessage = "Member has pending shifts and cannot be removed"
			return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
		}

		// delete AssignedShifts By ChannelId ShiftGroupId And UserId
		for _, assignedShift := range assignedShifts {
			assignedShiftDelRes, err := util.DeleteAssignedShift(&assignedShift.ID, authUserID)
			if err != nil {
				sentry.CaptureException(err)
				defer sentry.Flush(2 * time.Second)

				errorMessage = err.Error()
				util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeNotFound)
			}

			if assignedShiftDelRes != "success" {
				errorMessage = "Error deleting assigned shift"
				util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
				fmt.Println("Error deleting assigned shift")
			}
		}
	}

	// delete UserTimeOffs ( time off ) By ChannelId ShiftGroupId And UserId
	timeOffDelRes, err := util.DeleteTimeOff(&channelID, &shiftGroupID, &userID, authUserID)
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
	}

	if timeOffDelRes != "success" {
		errorMessage = "Error deleting time off"
		util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeRequired)
		fmt.Println("Error deleting time off")
	}

	// delete ShiftGroup Members By ChannelId ShiftGroupId And UserId
	var shiftGroupMember *model.ShiftGroupMember
	err = r.DB.Clauses(clause.Returning{}).Where("channel_id = ? AND shift_group_id = ? AND user_id = ?", channelID, shiftGroupID, userID).Delete(&shiftGroupMember).Error
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	}

	if shiftGroupMember.ID == "" {
		errorMessage = "Shift Group Member not found"
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeNotFound)

	}

	// get the user from the user service and return it
	user, err := util.GetUser(userID)

	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		errorMessage = err.Error()
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeInvalid)
	}

	if &user.ID == nil || user.ID == "" {
		errorMessage = "User not found"
		return util.ShiftGroupMemberRemoveRHandleError(&errorMessage, model.ShiftErrorCodeNotFound)
	}

	return &model.ShiftGroupMemberRemoveResponse{
		Errors: nil,
		User:   user,
	}, nil
}

// CreateTimeOff is the resolver for the createTimeOff field.
func (r *mutationResolver) CreateTimeOff(ctx context.Context, input model.TimeOffInput, authUserID *string) (*model.TimeOffAddResponse, error) {
	panic(fmt.Errorf("not implemented: CreateTimeOff - createTimeOff"))
}

// UpdateTimeOff is the resolver for the updateTimeOff field.
func (r *mutationResolver) UpdateTimeOff(ctx context.Context, id string, input model.TimeOffInput, authUserID *string) (*model.TimeOffEditResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateTimeOff - updateTimeOff"))
}

// DeleteTimeOff is the resolver for the deleteTimeOff field.
func (r *mutationResolver) DeleteTimeOff(ctx context.Context, id string, authUserID *string) (*model.TimeOffDeleteResponse, error) {
	panic(fmt.Errorf("not implemented: DeleteTimeOff - deleteTimeOff"))
}

// DeleteTimeOffs is the resolver for the deleteTimeOffs field.
func (r *mutationResolver) DeleteTimeOffs(ctx context.Context, channelID string, shiftGroupID string, userID string, authUserID *string) (string, error) {
	panic(fmt.Errorf("not implemented: DeleteTimeOffs - deleteTimeOffs"))
}

// GetNonShiftGroupMembers is the resolver for the getNonShiftGroupMembers field.
func (r *queryResolver) GetNonShiftGroupMembers(ctx context.Context, channelID string, shiftGroupID string, authUserID *string) (*model.GetNonShiftGroupMembersResponse, error) {
	var message, status string
	// if authUserID == nil || *authUserID == string("") {
	// 	message = AUTH_USER_ID_REQUIRED
	// 	status = "error"

	// 	return &model.GetNonShiftGroupMembersResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	message = err.Error()
	// 	status = "error"

	// 	return &model.GetNonShiftGroupMembersResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		message = err.Error()
	// 		status = "error"

	// 		return &model.GetNonShiftGroupMembersResponse{
	// 			Message: &message,
	// 			Status:  &status,
	// 			Result:  nil,
	// 		}, nil
	// 	}
	// }

	// if !permission {
	// 	message = "Permission denied: shift_group_member.READ, shift_group_member.READ_ALL"
	// 	status = "error"

	// 	return &model.GetNonShiftGroupMembersResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	if channelID == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	if shiftGroupID == "" {
		return nil, fmt.Errorf("shiftGroupID is required")
	}

	// get Shift Group Members By ChannelId And ShiftGroupId
	var shiftGroupMembers []*model.ShiftGroupMember
	err = r.DB.Where("channel_id = ? AND shift_group_id = ?", channelID, shiftGroupID).Find(&shiftGroupMembers).Error

	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		message = err.Error()
		status = "error"

		return &model.GetNonShiftGroupMembersResponse{
			Message: &message,
			Status:  &status,
			Result:  nil,
		}, nil
	}

	// get all users by is_staff = true
	users, err := util.GetUsersByIsStaff(true)
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		message = err.Error()
		status = "error"

		return &model.GetNonShiftGroupMembersResponse{
			Message: &message,
			Status:  &status,
			Result:  nil,
		}, nil
	}

	// check if there is at least one user
	if len(users) == 0 {
		message = "No user found"
		status = "error"

		return &model.GetNonShiftGroupMembersResponse{
			Message: &message,
			Status:  &status,
			Result:  nil,
		}, nil
	}

	// user result
	var res []*model.User

	for _, user := range users {
		noRecord := false
		for _, shiftGroupMember := range shiftGroupMembers {
			if user.ID == shiftGroupMember.UserID {
				noRecord = true
				break
			}
		}
		if !noRecord {
			isAdded := false
			for _, item := range res {
				if item.ID == user.ID {
					isAdded = true
					break
				}
			}
			if !isAdded {
				res = append(res, user)
			}
		}
	}

	countNonShiftMembers := len(res)

	// map res data in mode.User
	var nonShiftGroupMembers []*model.User
	for _, user := range res {
		nonShiftGroupMembers = append(nonShiftGroupMembers, user)
	}

	message = fmt.Sprintf("%d non shift group members", countNonShiftMembers)
	status = "success"

	return &model.GetNonShiftGroupMembersResponse{
		Message: &message,
		Result:  nonShiftGroupMembers,
		Status:  &status,
	}, nil
}

// GetShiftGroupMembers is the resolver for the getShiftGroupMembers field.
func (r *queryResolver) GetShiftGroupMembers(ctx context.Context, shiftGroupID string, channel string, authUserID *string) ([]*model.User, error) {
	// if authUserID == nil || *authUserID == string("") {
	// 	return nil, fmt.Errorf(AUTH_USER_ID_REQUIRED)
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	return nil, err
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		return nil, err
	// 	}
	// }
	// if !permission {
	// 	return nil, fmt.Errorf("Permission denied: shift_group_member.READ, shift_group_member.READ_ALL")
	// }

	// validate the input
	if shiftGroupID == "" {
		return nil, fmt.Errorf("shiftGroup Id is required")
	}

	if channel == "" {
		return nil, fmt.Errorf("channel slug is required")
	}

	channelRes, err := util.GetChannelBySlug(channel)
	if err != nil {

		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		return nil, err
	}

	if &channelRes.Data.Channel.ID == nil || channelRes.Data.Channel.ID == "" {
		return nil, fmt.Errorf("channel not found")
	}

	channelId := channelRes.Data.Channel.ID
	// get shift group members by shift group id and channel id
	var shiftGroupMembers []*model.ShiftGroupMember
	err = r.DB.Where("shift_group_id = ? AND channel_id = ?", shiftGroupID, channelId).Find(&shiftGroupMembers).Error

	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		return nil, err
	}

	if len(shiftGroupMembers) == 0 {
		return nil, fmt.Errorf("No shift group members found")
	}

	// for each shift group member get the user from the user service
	var users []*model.User
	for _, shiftGroupMember := range shiftGroupMembers {
		user, err := util.GetUser(shiftGroupMember.UserID)
		if err != nil {
			sentry.CaptureException(err)
			defer sentry.Flush(2 * time.Second)
			return nil, err
		}
		users = append(users, user)
	}

	return users, nil
}

// GetAllShiftMembers is the resolver for the getAllShiftMembers field.
func (r *queryResolver) GetAllShiftMembers(ctx context.Context, first *int, last *int, authUserID *string) ([]*model.User, error) {
	// if authUserID == nil || *authUserID == string("") {
	// 	return nil, fmt.Errorf(AUTH_USER_ID_REQUIRED)
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	return nil, err
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		return nil, err
	// 	}
	// }
	// if !permission {
	// 	return nil, fmt.Errorf("Permission denied: shift_group_member.READ, shift_group_member.READ_ALL")
	// }

	var users []*model.User

	if first != nil {
		users, err = util.GetUsers(first, nil)
	} else if last != nil {
		users, err = util.GetUsers(nil, last)
	} else {
		users, err = util.GetUsers(nil, nil)
	}

	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)
		return nil, err
	}

	return users, nil
}

// GetAllUniqueShifts is the resolver for the getAllUniqueShifts field.
func (r *queryResolver) GetAllUniqueShifts(ctx context.Context, channelID string, shiftGroupID string, authUserID *string) (*model.GetAllUniqueShiftsResponse, error) {
	var message, status string
	// if authUserID == nil || *authUserID == string("") {
	// 	message = AUTH_USER_ID_REQUIRED
	// 	status = "error"

	// 	return &model.GetAllUniqueShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	message = err.Error()
	// 	status = "error"

	// 	return &model.GetAllUniqueShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		message = err.Error()
	// 		status = "error"

	// 		return &model.GetAllUniqueShiftsResponse{
	// 			Message: &message,
	// 			Status:  &status,
	// 			Result:  nil,
	// 		}, nil
	// 	}
	// }
	// if !permission {
	// 	message = "Permission denied: shift_group_member.READ, shift_group_member.READ_ALL"
	// 	status = "error"

	// 	return &model.GetAllUniqueShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	if channelID == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	if shiftGroupID == "" {
		return nil, fmt.Errorf("shiftGroupID is required")
	}

	// get assigned shifts by channel id and shift group id
	assignedShifts, err := util.GetAssignedShiftsByChannelIDShiftGroupID(&channelID, &shiftGroupID)
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		message = err.Error()
		status = "error"

		return &model.GetAllUniqueShiftsResponse{
			Message: &message,
			Status:  &status,
			Result:  nil,
		}, nil
	}

	// get open shifts by channel id and shift group id
	openShifts, err := util.GetOpenShiftsByChannelIDShiftGroupID(&channelID, &shiftGroupID, authUserID)
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		message = err.Error()
		status = "error"

		return &model.GetAllUniqueShiftsResponse{
			Message: &message,
			Status:  &status,
			Result:  nil,
		}, nil
	}

	message = "Fetch successful"
	status = "success"
	return &model.GetAllUniqueShiftsResponse{
		Result: &model.UniqueShifts{
			AssignedShifts: assignedShifts,
			OpenShifts:     openShifts,
		},
		Message: &message,
		Status:  &status,
	}, nil
}

// GetShiftsByPeople is the resolver for the getShiftsByPeople field.
func (r *queryResolver) GetShiftsByPeople(ctx context.Context, channelID string, endDate time.Time, filter *model.GetShiftsFilter, shiftGroupID string, startDate time.Time, authUserID *string) (*model.GetShiftsResponse, error) {
	var message, status string
	// if authUserID == nil || *authUserID == string("") {
	// 	message = AUTH_USER_ID_REQUIRED
	// 	status = "error"

	// 	return &model.GetShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	message = err.Error()
	// 	status = "error"

	// 	return &model.GetShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		message = err.Error()
	// 		status = "error"

	// 		return &model.GetShiftsResponse{
	// 			Message: &message,
	// 			Status:  &status,
	// 			Result:  nil,
	// 		}, nil
	// 	}
	// }

	// if !permission {
	// 	message = "Permission denied: shift_group_member.READ, shift_group_member.READ_ALL"
	// 	status = "error"

	// 	return &model.GetShiftsResponse{
	// 		Message: &message,
	// 		Status:  &status,
	// 		Result:  nil,
	// 	}, nil
	// }

	if channelID == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	if endDate.IsZero() {
		return nil, fmt.Errorf("endDate is required")
	}

	if shiftGroupID == "" {
		return nil, fmt.Errorf("shiftGroupID is required")
	}

	if startDate.IsZero() {
		return nil, fmt.Errorf("startDate is required")
	}

	var userAssignedShifts []*model.UserAssignedShifts
	var assignedShifts []*model.AssignedShift
	var openShifts []*model.OpenShift
	title := "Open shifts"

	if filter != nil && *filter.IncludeOpenShifts {
		// get open shifts
		openShiftsChan := make(chan []*model.OpenShift)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			defer close(openShiftsChan)
			openShifts, err = util.GetOpenShiftsByTime(&channelID, &shiftGroupID, &endDate, &startDate)
			if err != nil {
				sentry.CaptureException(err)
				defer sentry.Flush(2 * time.Second)

				message = err.Error()
				status = "error"

				return
			}
			openShiftsChan <- openShifts
		}()
		timeout := time.After(30 * time.Second) // Set a timeout of 30 seconds
		select {
		case openShifts = <-openShiftsChan:
		// Do something with openShifts
		case <-timeout:
			// Handle timeout
			message = "Timed out while getting open shifts"
			status = "error"

			return &model.GetShiftsResponse{
				Message: &message,
				Status:  &status,
				Result:  nil,
			}, nil
		}

	}

	if filter != nil && *filter.IncludeShifts {
		// get ShiftGroupMembers By ChannelId And ShiftGroupId
		var shiftGroupMembers []*model.ShiftGroupMember
		err = r.DB.Where("channel_id = ? AND shift_group_id = ?", channelID, shiftGroupID).Find(&shiftGroupMembers).Error
		if err != nil {
			sentry.CaptureException(err)
			defer sentry.Flush(2 * time.Second)

			message = err.Error()
			status = "error"

			return &model.GetShiftsResponse{
				Message: &message,
				Status:  &status,
				Result:  nil,
			}, nil
		}

		if len(shiftGroupMembers) == 0 {
			message = "No Shift Group Member found"
			status = "error"

			return &model.GetShiftsResponse{
				Message: &message,
				Status:  &status,
				Result:  nil,
			}, nil
		}

		for _, shiftGroupMember := range shiftGroupMembers {
			// get assignedShifts
			assignedShifts, err = util.GetAssignedShiftsByTime(&channelID, &shiftGroupID, &shiftGroupMember.UserID, &endDate, &startDate)
			if err != nil {
				sentry.CaptureException(err)
				defer sentry.Flush(2 * time.Second)

				message = err.Error()
				status = "error"

				return &model.GetShiftsResponse{
					Message: &message,
					Status:  &status,
					Result:  nil,
				}, nil
			}

			numberOfHours := 0
			for _, assignedShift := range assignedShifts {
				numberOfHours += util.DiffHours(assignedShift.EndTime, assignedShift.StartTime)
			}

			// get the user firstName and lastName from User
			user, err := util.GetUser(shiftGroupMember.UserID)
			if err != nil {
				sentry.CaptureException(err)
				defer sentry.Flush(2 * time.Second)

				message = err.Error()
				status = "error"

				return &model.GetShiftsResponse{
					Message: &message,
					Status:  &status,
					Result:  nil,
				}, nil
			}

			avatar := ""
			fullName := ""
			userId := ""
			if user.ID == shiftGroupMember.UserID {
				fullName = user.FirstName + " " + user.LastName
				if user.Avatar == nil {
					avatar = ""
				} else {
					avatar = *user.Avatar
				}
				userId = user.ID

				userAssignedShifts = append(userAssignedShifts, &model.UserAssignedShifts{
					UserID:        userId,
					Name:          fullName,
					Image:         &avatar,
					Shifts:        assignedShifts,
					NumberOfHours: numberOfHours,
				},
				)
			}
		}
	}

	message = "Fetch successful"
	status = "success"
	numberOfShifts := len(openShifts)
	return &model.GetShiftsResponse{
		Message: &message,
		Status:  &status,
		Result: &model.Shifts{
			AssignedShifts: userAssignedShifts,
			OpenShifts: &model.OpenShiftInfo{
				Title:          &title,
				NumberOfShifts: &numberOfShifts,
				Shifts:         openShifts,
			},
		},
	}, nil
}

// GetShiftsByTask is the resolver for the getShiftsByTask field.
// GetShiftsByTask is the resolver for the getShiftsByTask field.
func (r *queryResolver) GetShiftsByTask(ctx context.Context, channelID string, endDate time.Time, filter *model.GetShiftsFilter, startDate time.Time, authUserID *string) (*model.GetShiftsByTaskResponse, error) {
	var (
		// openShifts         []*model.OpenShift
		// assignedShifts     []*model.AssignedShift
		requests *model.GetRequestsResponse
		// userAssignedShifts []*model.UserAssignedShifts
		result  []*model.ShiftGroups
		message string
		status  string
	)
	// if authUserID == nil || *authUserID == string("") {
	// 	message = AUTH_USER_ID_REQUIRED
	// 	status = "error"
	// 	return util.GetShiftsByTaskHandleError(&message, &status)
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	message = err.Error()
	// 	status = "error"
	// 	return util.GetShiftsByTaskHandleError(&message, &status)
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		message = err.Error()
	// 		status = "error"
	// 		return util.GetShiftsByTaskHandleError(&message, &status)
	// 	}
	// }
	// if !permission {
	// 	message = "Permission denied: shift_group_member.READ, shift_group_member.READ_ALL"
	// 	status = "error"
	// 	return util.GetShiftsByTaskHandleError(&message, &status)
	// }

	if channelID == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	if endDate.IsZero() {
		return nil, fmt.Errorf("endDate is required")
	}

	if startDate.IsZero() {
		return nil, fmt.Errorf("startDate is required")
	}

	// get shift groups by channel id
	shiftGroups, err := util.GetShiftGroups(&channelID, authUserID)
	if err != nil {
		message = err.Error()
		status = "error"
		return util.GetShiftsByTaskHandleError(&message, &status)
	}

	if len(shiftGroups) == 0 {
		message = "No shift groups found"
		status = "error"
		return util.GetShiftsByTaskHandleError(&message, &status)
	}

	title := "Open shifts"

	// filter shift groups by id
	if filter != nil && filter.ShiftGroupIds != nil {
		result := []*model.ShiftGroup{}
		for _, shiftGroup := range shiftGroups {
			for _, shiftGroupId := range filter.ShiftGroupIds {
				if shiftGroup.ID == shiftGroupId {
					result = append(result, shiftGroup)
				}
			}
		}
		shiftGroups = result
	}

	// loop through each shift group

	for _, shiftGroup := range shiftGroups {
		// retrieve shift group members for the current shift group only
		var shiftGroupMembers []*model.ShiftGroupMember

		openShifts := []*model.OpenShift{}
		assignedShifts := []*model.AssignedShift{}
		userAssignedShifts := []*model.UserAssignedShifts{}
		numberOfHours := 0

		err = r.DB.Where("channel_id = ? AND shift_group_id = ?", channelID, shiftGroup.ID).Find(&shiftGroupMembers).Error
		if err != nil {
			message = err.Error()
			status = "error"
			return util.GetShiftsByTaskHandleError(&message, &status)
		}

		if filter != nil && *filter.IncludeOpenShifts {
			// retrieve open shifts for the current shift group member only
			openShifts, err = util.GetOpenShiftsByTime(&channelID, &shiftGroup.ID, &endDate, &startDate)
			if err != nil {
				message = err.Error()
				status = "error"
				return util.GetShiftsByTaskHandleError(&message, &status)
			}
		}

		// filter shift group members by members
		if filter != nil && filter.ShiftGroupMemberIds != nil {
			err = r.DB.Where("user_id IN (?) AND shift_group_id = ? AND channel_id = ?", filter.ShiftGroupMemberIds, shiftGroup.ID, channelID).Find(&shiftGroupMembers).Error
			if err != nil {

				message = err.Error()
				status = "error"
				return util.GetShiftsByTaskHandleError(&message, &status)
			}
		}

		for _, shiftGroupMember := range shiftGroupMembers {
			var assignedShiftsTimeOff []*model.TimeOff

			if filter != nil && *filter.IncludeShifts {
				// retrieve assigned shifts for the current shift group member only
				assignedShifts, err = util.GetAssignedShiftsByTime(&channelID, &shiftGroup.ID, &shiftGroupMember.UserID, &endDate, &startDate)
				fmt.Println("retrieve assigned shifts for the current shift group member only ", assignedShifts)

				if err != nil {
					message = err.Error()
					status = "error"
					return util.GetShiftsByTaskHandleError(&message, &status)
				}

				for _, assignedShift := range assignedShifts {
					numberOfHours += util.DiffHours(assignedShift.EndTime, assignedShift.StartTime)
				}
			}

			if filter != nil && *filter.IncludeRequests {
				// retrieve requests for the current shift group member only
				requests, err = util.GetRequests(&channelID, &shiftGroupMember.UserID, authUserID)
				fmt.Println("retrieve requests for the current shift group member only ", requests)
				if err != nil {
					message = err.Error()
					status = "error"
					return util.GetShiftsByTaskHandleError(&message, &status)

				}
				// ------------------------------

				assignedShiftsTimeOff, err = util.GetTimeOffByTime(&channelID, &shiftGroup.ID, &endDate, &startDate, &shiftGroupMember.UserID, authUserID)

				fmt.Println("assignedShiftsTimeOff", assignedShiftsTimeOff)
				// -------------------------------
				for _, timeOff := range assignedShiftsTimeOff {
					taskType := "TIMEOFF"
					newTimeOff := &model.AssignedShift{
						ID:           timeOff.ID,
						StartTime:    timeOff.StartTime,
						Type:         &taskType,
						EndTime:      timeOff.EndTime,
						Label:        &timeOff.Label,
						Note:         &timeOff.Note,
						Color:        timeOff.Color,
						Is24Hours:    timeOff.Is24Hours,
						UserID:       timeOff.UserID,
						ChannelID:    timeOff.ChannelID,
						ShiftGroupID: timeOff.ShiftGroupID,
					}
					fmt.Println("------- ----- ----->>>", timeOff.Label)
					fmt.Println("------- ----- ----->>>", timeOff.Note)

					assignedShifts = append(assignedShifts, newTimeOff)
				}
				// -------------------------------

				for _, request := range requests.Data.GetRequestsByUser.Edges {
					// add the request to the assigned shifts
					var newShift *model.AssignedShift
					if *request.Node.Type != "TIMEOFF" {
						newShift = &model.AssignedShift{
							ID:        request.Node.ID,
							Type:      request.Node.Type,
							Color:     request.Node.ShiftToSwap.Color,
							Note:      request.Node.RequestNote,
							Label:     request.Node.ShiftToSwap.Label,
							Is24Hours: request.Node.IsAllDay,
							StartTime: request.Node.StartTime,
							EndTime:   request.Node.EndTime,
						}
					} else {
						newShift = &model.AssignedShift{
							ID:        request.Node.ID,
							Type:      request.Node.Type,
							Label:     request.Node.ShiftToSwap.Label,
							Color:     request.Node.ShiftToSwap.Color,
							Is24Hours: request.Node.IsAllDay,
							Note:      request.Node.RequestNote,
							StartTime: request.Node.StartTime,
							EndTime:   request.Node.EndTime,
						}
					}
					assignedShifts = append(assignedShifts, newShift)
				}
			}

			// get the user firstName and lastName from User
			user, err := util.GetUser(shiftGroupMember.UserID)
			if err != nil {
				message = err.Error()
				status = "error"
				return util.GetShiftsByTaskHandleError(&message, &status)
			}

			avatar := ""
			fullName := ""
			userId := ""
			if user.ID == shiftGroupMember.UserID {
				fullName = user.FirstName + " " + user.LastName
				if user.Avatar == nil {
					avatar = ""
				} else {
					avatar = *user.Avatar
				}
				userId = user.ID

				userAssignedShifts = append(userAssignedShifts, &model.UserAssignedShifts{
					UserID:        userId,
					Name:          fullName,
					Image:         &avatar,
					Shifts:        assignedShifts,
					NumberOfHours: numberOfHours,
				})
			}

		} // end of shiftGroupMembers loop
		// add shift groups to the result
		numberOfShifts := len(openShifts)
		shiftGroups := &model.ShiftGroups{
			GroupID:   shiftGroup.ID,
			GroupName: shiftGroup.Name,
			Shifts: &model.Shifts{
				AssignedShifts: userAssignedShifts,
				OpenShifts: &model.OpenShiftInfo{
					Title:          &title,
					NumberOfShifts: &numberOfShifts,
					Shifts:         openShifts,
				},
			},
		}
		result = append(result, shiftGroups)

	} // end of shiftGroups loop

	message = "Fetch successful"
	status = "success"
	return &model.GetShiftsByTaskResponse{
		Message: &message,
		Status:  &status,
		Result:  result,
	}, nil
}

// GetShiftGroupMembersList is the resolver for the getShiftGroupMembersList field.
func (r *queryResolver) GetShiftGroupMembersList(ctx context.Context, channelID string, shiftGroupID string, authUserID *string) ([]*model.ShiftGroupMember, error) {
	// if authUserID == nil || *authUserID == string("") {
	// 	return nil, fmt.Errorf(AUTH_USER_ID_REQUIRED)
	// }

	var err error
	// permission := false

	// // validate permission
	// permission, err = util.CheckPermission("shift_group_member", "READ_ALL", *authUserID)
	// if err != nil {
	// 	sentry.CaptureException(err)
	// 	defer sentry.Flush(2 * time.Second)

	// 	return nil, err
	// }

	// if !permission {
	// 	permission, err = util.CheckPermission("shift_group_member", "READ", *authUserID)
	// 	if err != nil {
	// 		sentry.CaptureException(err)
	// 		defer sentry.Flush(2 * time.Second)

	// 		return nil, err
	// 	}
	// }
	// if !permission {
	// 	return nil, fmt.Errorf("Permission denied: shift_group_member.READ, shift_group_member.READ_ALL")
	// }

	if channelID == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	if shiftGroupID == "" {
		return nil, fmt.Errorf("shiftGroupID is required")
	}

	var shiftGroupMembers []*model.ShiftGroupMember
	err = r.DB.Where("channel_id = ? AND shift_group_id = ?", channelID, shiftGroupID).Order("position").Find(&shiftGroupMembers).Error
	if err != nil {

		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		return nil, err
	}

	return shiftGroupMembers, nil
}

// GetTimeOff is the resolver for the getTimeOff field.
func (r *queryResolver) GetTimeOff(ctx context.Context, id string, authUserID *string) (*model.AssignedShift, error) {
	panic(fmt.Errorf("not implemented: GetTimeOff - getTimeOff"))
}

// GetTimeOffs is the resolver for the getTimeOffs field.
func (r *queryResolver) GetTimeOffs(ctx context.Context, channelID string, shiftGroupID string, userID string, startTime time.Time, endTime time.Time, authUserID *string) ([]*model.AssignedShift, error) {
	var err error
	var timeOffs []*model.TimeOff
	err = r.DB.Where("channel_id = ? AND shift_group_id = ? AND user_id = ? AND start_time >= ? AND end_time <= ?", channelID, shiftGroupID, userID, startTime, endTime).Find(&timeOffs).Error
	if err != nil {
		sentry.CaptureException(err)
		defer sentry.Flush(2 * time.Second)

		return nil, err
	}

	var assignedShifts []*model.AssignedShift
	for _, timeOff := range timeOffs {
		taskType := "timeoff"
		assignedShift := model.AssignedShift{
			ID:           timeOff.ID,
			Type:         &taskType,
			StartTime:    timeOff.StartTime,
			EndTime:      timeOff.EndTime,
			Label:        &timeOff.Label,
			Note:         &timeOff.Note,
			Color:        timeOff.Color,
			Is24Hours:    timeOff.Is24Hours,
			UserID:       timeOff.UserID,
			ChannelID:    timeOff.ChannelID,
			ShiftGroupID: timeOff.ShiftGroupID,
		}

		assignedShifts = append(assignedShifts, &assignedShift)
	}

	return assignedShifts, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
